// Copyright IBM Corp. 2023, 2024
import wxflows_main from '../wxflows.js';
class wxflows extends wxflows_main {
    constructor({ endpoint, apikey }) {
        super({ endpoint, apikey });
        this.invokeTool = async ({ name, args, id }) => {
            return Promise.all([this._lcCoreMessagesModule]).then(async ([{ ToolMessage }]) => {
                try {
                    const response = await this.execTool(name, args);
                    return new ToolMessage({
                        artifact: response,
                        tool_call_id: id,
                        status: 'success',
                        content: JSON.stringify(response),
                    });
                }
                catch (e) {
                    if (e instanceof Error) {
                        return new ToolMessage({
                            artifact: {
                                error: e.message,
                            },
                            tool_call_id: id,
                            status: 'error',
                            content: JSON.stringify(e.message),
                        });
                    }
                }
            });
        };
        this._lcCoreToolsModule = import('@langchain/core/tools');
        this._lcCoreMessagesModule = import('@langchain/core/messages');
        this._zodModule = import('zod');
    }
    get lcTools() {
        return Promise.all([
            this.tools,
            this._lcCoreToolsModule,
            this._zodModule,
        ]).then(([tcTools, { tool }, { z }]) => {
            if (tcTools.length > 0) {
                const tools = [];
                tcTools.forEach((tcTool) => {
                    const { name, description, parameters } = tcTool.function;
                    let schema = {};
                    if (name && description && parameters) {
                        for (const key in parameters.properties) {
                            if (parameters.properties.hasOwnProperty(key)) {
                                schema[key] = z
                                    .string()
                                    .describe(parameters.properties[key].description);
                            }
                        }
                        const langchainTool = tool(async (variables) => {
                            // Type for `query` is know, type of other fields not
                            let toolArguments = {};
                            for (const key in variables) {
                                if (variables.hasOwnProperty(key)) {
                                    let value = variables[key];
                                    // lanchain seems to turn objects into string somewhere along the way
                                    if (parameters?.properties?.[key].type === 'object') {
                                        value = JSON.parse(value) || value;
                                    }
                                    toolArguments[key] = value;
                                }
                            }
                            try {
                                const response = await this.execTool(name, toolArguments);
                                return response ? JSON.stringify(response) : '';
                            }
                            catch (e) {
                                if (e instanceof Error) {
                                    return JSON.stringify(e.message);
                                }
                            }
                            return '';
                        }, {
                            name,
                            description,
                            schema: z.object(schema),
                        });
                        tools.push(langchainTool);
                    }
                });
                return tools;
            }
            return [];
        });
    }
}
export default wxflows;
//# sourceMappingURL=index.js.map