// Copyright IBM Corp. 2023, 2024
import _ from 'lodash';
import { request } from 'graphql-request';
import { createChatSystemPrompt, fetchOpenAIChatContent, fetchTools, } from './chat.js';
import { fetchFlow } from './flow.js';
import { generateSchema } from './generate.js';
import { findFields } from './getFields.js';
import { fetchRag } from './rag.js';
class wxflows {
    get tools() {
        if (!this._tools) {
            this._tools = fetchTools({ endpoint: this.endpoint, apikey: this.apikey });
        }
        return this._tools;
    }
    constructor({ endpoint, apikey, flowName }) {
        this.execGraphQL = async (document, variables = {}) => {
            const headers = {
                'Content-Type': 'application/json',
            };
            if (this.apikey) {
                headers['Authorization'] = `apikey ${this.apikey}`;
            }
            try {
                const data = await request({
                    url: this.endpoint,
                    document,
                    variables,
                    requestHeaders: headers,
                });
                return { result: data };
            }
            catch (e) {
                console.log(e);
                if (e instanceof Error) {
                    return { error: e.message };
                }
                return { error: 'Something went wrong' };
            }
        };
        this.execTool = async (name, toolArguments) => {
            // check if the tool is a GraphQL tool and can be called directly
            if (toolArguments?.query) {
                const tools = await this._tools;
                if (tools?.find((value) => value.function.name === name && value.__typename === 'TC_GraphQL')) {
                    return await this.execGraphQL(toolArguments.query);
                }
            }
            const query = /* GraphQL */ `
      query tc_($name: String!, $values: JSON!) {
        tc_function(name: $name, values: $values) {
          data
        }
      }
    `;
            return await this.execGraphQL(query, {
                name,
                values: toolArguments,
            });
        };
        this.flow = async ({ schema, flowName, variables, query, }) => {
            const ragVars = this.vars?.rag
                ? _.merge(variables, this.vars?.rag)
                : variables;
            const flow = flowName || this.flowName;
            const inputQuery = query;
            if (flow) {
                const response = await fetchFlow(this.endpoint, flow, schema, this.apikey, ragVars, inputQuery);
                return response;
            }
            else {
                return 'Please provide the flowName to wxflows';
            }
        };
        this.generate = async () => {
            const response = await generateSchema(this.endpoint, this.apikey);
            if (response?.error?.message) {
                return response?.error?.message;
            }
            else {
                return JSON.stringify(response);
            }
        };
        this.getFields = ({ schema }) => {
            const response = findFields(schema);
            return JSON.stringify(response);
        };
        this.ragAnswer = async ({ schema, flowName, variables, query, }) => {
            const ragVars = this.vars?.rag
                ? _.merge(variables, this.vars?.rag)
                : variables;
            const flow = flowName || this.flowName;
            const inputQuery = query;
            if (flow) {
                const response = await fetchRag(this.endpoint, flow, schema, this.apikey, ragVars, inputQuery);
                return response;
            }
            else {
                return 'Please provide the flowName to wxflows';
            }
        };
        this.endpoint = endpoint;
        this.apikey = apikey;
        this.flowName = flowName;
    }
    async chatContent(field, messages) {
        const supported = ['openAI_ChatContent'];
        if (supported.includes(field)) {
            const tools = await this.tools;
            if (messages.findIndex(({ role }) => role === 'system') === -1) {
                messages.unshift({
                    role: 'system',
                    content: createChatSystemPrompt(tools),
                });
            }
            return fetchOpenAIChatContent({
                endpoint: this.endpoint,
                apikey: this.apikey,
                messages,
                tools: await this.tools,
            });
        }
        throw new Error(`Chatting with tools via the ${field} is not currently supported.` +
            ` Supported fields: [ ${supported.join(', ')} ]`);
    }
    async call(prompt) {
        const schema = await this.generate();
        const result = await this.flow({
            schema,
            flowName: this.flowName,
            variables: { question: prompt.value },
        });
        return result;
    }
    pipe() {
        // This method should return a new instance of the model
        return new wxflows(this);
    }
    async invoke(prompt) {
        // Use the model to generate a response
        const response = await this.call(prompt);
        return response;
    }
}
export const executeFlow = async ({ flowName, variables, endpoint = process.env.WXFLOWS_ENDPOINT, apikey = process.env.WXFLOWS_APIKEY, query, }) => {
    if (!endpoint) {
        return ('Please provide an endpoint to wxflows. Either pass it in as a' +
            ' parameter to executeFlow() or define the WXFLOWS_ENDPOINT' +
            ' environment variable.');
    }
    const model = new wxflows({ endpoint, apikey, flowName });
    const schema = await model.generate();
    return model.flow({
        schema,
        flowName,
        variables,
        query,
    });
};
export default wxflows;
//# sourceMappingURL=wxflows.js.map