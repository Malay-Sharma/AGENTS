// Copyright IBM Corp. 2023, 2024
import _ from 'lodash'
import {request} from 'graphql-request'

import {
  createChatSystemPrompt,
  fetchOpenAIChatContent,
  fetchTools,
  type ChatMessage,
  type WxflowsTool,
} from './chat.js'
import {fetchFlow} from './flow.js'
import {generateSchema} from './generate.js'
import {findFields} from './getFields.js'
import {RagVars, fetchRag} from './rag.js'

export interface WxflowsProps {
  endpoint: string
  apikey?: string
  flowName?: string
}

type PromptProps = {
  lc_serializable: true
  lc_kwargs: {value: string}
  lc_namespace: [string]
  value: string
}

class wxflows {
  endpoint: string
  apikey?: string
  flowName?: string
  vars?: {
    rag?: RagVars
  }

  private _tools?: Promise<WxflowsTool[]>
  get tools() {
    if (!this._tools) {
      this._tools = fetchTools({endpoint: this.endpoint, apikey: this.apikey})
    }

    return this._tools
  }

  constructor({endpoint, apikey, flowName}: WxflowsProps) {
    this.endpoint = endpoint
    this.apikey = apikey
    this.flowName = flowName
  }

  execGraphQL = async <R = unknown>(
    document: string,
    variables: Record<string, any> = {},
  ): Promise<{result: R; error?: never} | {error: string}> => {
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    }

    if (this.apikey) {
      headers['Authorization'] = `apikey ${this.apikey}`
    }

    try {
      const data = await request<R>({
        url: this.endpoint,
        document,
        variables,
        requestHeaders: headers,
      })
      return {result: data}
    } catch (e) {
      console.log(e)

      if (e instanceof Error) {
        return {error: e.message}
      }
      return {error: 'Something went wrong'}
    }
  }

  execTool = async <R = unknown>(
    name: string,
    toolArguments: {query?: string; [key: string]: unknown},
  ): Promise<{result: R; error?: never} | {error: string}> => {
    // check if the tool is a GraphQL tool and can be called directly
    if (toolArguments?.query) {
      const tools = await this._tools

      if (
        tools?.find(
          (value) =>
            value.function.name === name && value.__typename === 'TC_GraphQL',
        )
      ) {
        return await this.execGraphQL(toolArguments.query)
      }
    }

    const query = /* GraphQL */ `
      query tc_($name: String!, $values: JSON!) {
        tc_function(name: $name, values: $values) {
          data
        }
      }
    `

    return await this.execGraphQL(query, {
      name,
      values: toolArguments,
    })
  }

  flow = async ({
    schema,
    flowName,
    variables,
    query,
  }: {
    schema: string
    flowName?: string
    variables?: RagVars
    query?: string
  }) => {
    const ragVars = this.vars?.rag
      ? _.merge(variables, this.vars?.rag)
      : variables

    const flow = flowName || (this.flowName as string)
    const inputQuery = query

    if (flow) {
      const response = await fetchFlow(
        this.endpoint,
        flow,
        schema,
        this.apikey,
        ragVars,
        inputQuery,
      )
      return response
    } else {
      return 'Please provide the flowName to wxflows'
    }
  }

  generate = async () => {
    const response = await generateSchema(this.endpoint, this.apikey)
    if (response?.error?.message) {
      return response?.error?.message
    } else {
      return JSON.stringify(response)
    }
  }

  getFields = ({schema}: {schema: string}) => {
    const response = findFields(schema)

    return JSON.stringify(response)
  }

  ragAnswer = async ({
    schema,
    flowName,
    variables,
    query,
  }: {
    schema: string
    flowName?: string
    variables?: RagVars
    query?: string
  }) => {
    const ragVars = this.vars?.rag
      ? _.merge(variables, this.vars?.rag)
      : variables

    const flow = flowName || (this.flowName as string)
    const inputQuery = query

    if (flow) {
      const response = await fetchRag(
        this.endpoint,
        flow,
        schema,
        this.apikey,
        ragVars,
        inputQuery,
      )
      return response
    } else {
      return 'Please provide the flowName to wxflows'
    }
  }

  async chatContent(
    field: string,
    messages: ChatMessage[],
  ): Promise<ChatMessage> {
    const supported = ['openAI_ChatContent']
    if (supported.includes(field)) {
      const tools = await this.tools
      if (messages.findIndex(({role}) => role === 'system') === -1) {
        messages.unshift({
          role: 'system',
          content: createChatSystemPrompt(tools),
        })
      }

      return fetchOpenAIChatContent({
        endpoint: this.endpoint,
        apikey: this.apikey,
        messages,
        tools: await this.tools,
      })
    }

    throw new Error(
      `Chatting with tools via the ${field} is not currently supported.` +
        ` Supported fields: [ ${supported.join(', ')} ]`,
    )
  }

  async call(prompt: PromptProps) {
    const schema = await this.generate()
    const result = await this.flow({
      schema,
      flowName: this.flowName,
      variables: {question: prompt.value},
    })

    return result
  }

  pipe() {
    // This method should return a new instance of the model
    return new wxflows(this)
  }

  async invoke(prompt: PromptProps) {
    // Use the model to generate a response
    const response = await this.call(prompt)
    return response
  }
}

export const executeFlow = async ({
  flowName,
  variables,
  endpoint = process.env.WXFLOWS_ENDPOINT,
  apikey = process.env.WXFLOWS_APIKEY,
  query,
}: {
  flowName: string
  variables?: Record<string, any>
  endpoint?: string
  apikey?: string
  query?: string
}): Promise<
  | string
  | {
      data: unknown
      extensions: unknown
    }
> => {
  if (!endpoint) {
    return (
      'Please provide an endpoint to wxflows. Either pass it in as a' +
      ' parameter to executeFlow() or define the WXFLOWS_ENDPOINT' +
      ' environment variable.'
    )
  }

  const model = new wxflows({endpoint, apikey, flowName})
  const schema = await model.generate()
  return model.flow({
    schema,
    flowName,
    variables,
    query,
  })
}

export default wxflows
