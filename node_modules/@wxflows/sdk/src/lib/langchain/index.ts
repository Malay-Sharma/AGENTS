// Copyright IBM Corp. 2023, 2024
import wxflows_main, {type WxflowsProps} from '../wxflows.js'

import {type DynamicStructuredTool} from '@langchain/core/tools'
import {type z} from 'zod'

type IncomingToolCall = {
  name: string
  args: {query?: string; [key: string]: any}
  id: string
}

class wxflows extends wxflows_main {
  _lcCoreToolsModule: Promise<typeof import('@langchain/core/tools')>
  _lcCoreMessagesModule: Promise<typeof import('@langchain/core/messages')>
  _zodModule: Promise<typeof import('zod')>

  constructor({endpoint, apikey}: WxflowsProps) {
    super({endpoint, apikey})
    this._lcCoreToolsModule = import('@langchain/core/tools')
    this._lcCoreMessagesModule = import('@langchain/core/messages')
    this._zodModule = import('zod')
  }

  get lcTools() {
    return Promise.all([
      this.tools,
      this._lcCoreToolsModule,
      this._zodModule,
    ]).then(([tcTools, {tool}, {z}]) => {
      if (tcTools.length > 0) {
        const tools: DynamicStructuredTool<
          z.ZodObject<
            {query?: z.ZodString; [key: string]: any},
            'strip',
            z.ZodTypeAny,
            {query?: string; [key: string]: any},
            {query?: string; [key: string]: any}
          >
        >[] = []

        tcTools.forEach((tcTool) => {
          const {name, description, parameters} = tcTool.function
          let schema: {[key: string]: z.ZodString} = {}

          if (name && description && parameters) {
            for (const key in parameters.properties) {
              if (parameters.properties.hasOwnProperty(key)) {
                schema[key] = z
                  .string()
                  .describe(parameters.properties[key].description)
              }
            }

            const langchainTool = tool(
              async (variables: {[key: string]: any}) => {
                // Type for `query` is know, type of other fields not
                let toolArguments = <{query?: string; [key: string]: any}>{}
                for (const key in variables) {
                  if (variables.hasOwnProperty(key)) {
                    let value = variables[key]

                    // lanchain seems to turn objects into string somewhere along the way
                    if (parameters?.properties?.[key].type === 'object') {
                      value = JSON.parse(value) || value
                    }

                    toolArguments[key] = value
                  }
                }

                try {
                  const response = await this.execTool(name, toolArguments)

                  return response ? JSON.stringify(response) : ''
                } catch (e) {
                  if (e instanceof Error) {
                    return JSON.stringify(e.message)
                  }
                }

                return ''
              },
              {
                name,
                description,
                schema: z.object(schema),
              },
            )

            tools.push(langchainTool)
          }
        })

        return tools
      }

      return []
    })
  }

  invokeTool = async ({name, args, id}: IncomingToolCall) => {
    return Promise.all([this._lcCoreMessagesModule]).then(
      async ([{ToolMessage}]) => {
        try {
          const response = await this.execTool(name, args)

          return new ToolMessage({
            artifact: response,
            tool_call_id: id,
            status: 'success',
            content: JSON.stringify(response),
          })
        } catch (e) {
          if (e instanceof Error) {
            return new ToolMessage({
              artifact: {
                error: e.message,
              },
              tool_call_id: id,
              status: 'error',
              content: JSON.stringify(e.message),
            })
          }
        }
      },
    )
  }
}

export default wxflows
